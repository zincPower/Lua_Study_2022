---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangpengyong.
--- DateTime: 2022/4/11 16:55
---

s1 = "hello world"
s2 = "a [world]"

date = "Today is 12/04/2022"

print("------------------")
print("string.find(s, pattern, init, plain)")
do
    print("string.find")
    -- string.find
    local i, j = string.find(s1, "hello")
    print(i, j)
    print(string.sub(s1, i, j))
    print(string.sub(s1, s1:find("world")))

    print("string.find 指定起始位置")
    print(string.find(s1, "hello", 1))
    print(string.find(s1, "hello", 2))

    print("string.find 简单匹配")
    -- 因为 [ 是特殊字符，所以需要强制开启简单搜索模式
    --print(s2:find("["))
    print(string.find(s2, "[world]", 1, true))
    print(string.find(s2, "[world]", 1, false))

    print("string.find 正则匹配")
    print(string.sub(date, string.find(date, "%d+/%d+/%d+")))
    -- %a* 可以匹配 0-n 字母，会匹配到开头的空字符串
    local s3 = ";$%  **#$hello13"
    print(string.sub(s3, string.find(s3, "%a+", 3)))
end

print("------------------")
print("string.match(s, pattern, init)")
do
    print(string.match(s1, "hello"))
    print(string.match(date, "%d+/%d+/%d+"))
end

print("------------------")
print("string.gsub(s, pattern, repl, n)")
do
    print(string.gsub("Lua is cute", "cute", "great"))
    print(string.gsub("jiang peng yong", "n", "0"))
    -- 只替换一次
    print(string.gsub("jiang peng yong", "n", "0", 1))
    -- 只替换两次
    print(string.gsub("jiang peng yong", "n", "0", 2))

    local content = "My name is $name. I'm $age old."
    local info = {
        name = "jiang peng yong",
        age = 29
    }
    -- 会将匹配到的内容作为键，在 info 中查找对应的值，进行替换，如果查询不到则为 nil ，则不替换
    print(string.gsub(content, "$(%a+)", info))
    -- 会将匹配到的内容作为参数，传入函数，会将返回值进行替换，如果为 nil ，则不替换
    print(string.gsub(content, "$(%a+)", function(key)
        print("sub key is ", key)
        if key == "name" then
            return "江澎涌"
        end
        return "nil"
    end))
    -- 如果多个捕获，则可以用多个参数进行接收
    print(string.gsub(content, "($)(%a+)", function(key1, key2)
        print("sub key is ", key1, key2)
        if key1 == "name" then
            return "江澎涌"
        end
        return "nil"
    end))
end

print("------------------")
print("string.gmatch(s, pattern)")
do
    s = "some thing"
    words = {}
    for w in string.gmatch(s, "%a+") do
        words[#words + 1] = w
    end
    for i, v in ipairs(words) do
        print(i, "-->", v)
    end
end

print("------------------")
print("字符：")
do
    print(string.gsub("one, and two; and three", "%a", "."))
    print(string.gsub("one, and two; and three", "%A", "."))

    -- %bxy 会进行成对匹配字符串，x 和 y 可以是任意字符，x 作为其实字符而 y 作为结束字符
    print(string.gsub("a (enclosed (in) parentheses) line", " %b() ", " Jiang "))

    s = "the anthem is the theme"
    -- %f[char-set] 模式，只有后一个字符位于 char-set 内而前一个字符不在时，符合匹配
    -- %f[%w]the%f[%W] 这样只能完整匹配 "the"
    -- %f[%w] 表示前一字符不是字母和数字，后一个字符是字母或数字
    -- %f[%W] 表示前一字符是字母和数字，后一个字符不是字母或数字
    -- 所以使用这一匹配 "anthem" 和 "theme" 的 "the" 不算被匹配
    print(string.gsub(s, "%f[%w]the%f[%W]", "Jiang"))
    print(string.gsub(s, "the", "Jiang"))
end

print("------------------")
print("魔法字符：")
do
    local text = "123abc%d123"
    -- ^ 表示匹配目标字符串开始
    print(string.gsub(text, "^%d", "."))
    -- $ 表示匹配目标字符串结束
    print(string.gsub(text, "%d$", "."))
    -- 什么都使用的话，就是直接匹配所有可匹配的数字
    print(string.gsub(text, "%d", "."))
    -- 使用 %% 则将 %
    print(string.gsub(text, "%%d", "."))
    -- 替换所有字母和数字
    print(string.gsub(text, "[%a%d]", "$"))
    -- 替换所有非数字
    print(string.gsub(text, "[^%d]", "$"))
    -- 就和之前的用大写字母表示补集是一样的
    print(string.gsub(text, "%D", "$"))
end

print("------------------")
print("修饰符、限定符：")
do
    -- %a+ 会尽可能的匹配最长序列，例如会匹配整个 Jiang ，而不只是 Ji 或 Jian
    print(string.gsub("Jiang peng yong", "%a+", "J"))
    -- * 和 + 都会匹配最长序列，区别在于 * 可以匹配零个，所以当不确定中间是否有存在字符时，可用 *
    print(string.gsub("Jiang++peng+   +yong", "+%s*+", " "))

    local content = "/* 名字 */ int name; /* 年龄 */ int age;"
    -- 因为 * 是特殊字符，所以如果需要使用原本含义则需要转义，即 %*
    -- . 会匹配任意字符，
    -- .* 会匹配最长的序列，则会导致匹配最后的 */
    -- .- 会匹配最小的序列，则会匹配中间的 */
    print(string.gsub(content, "/%*.*%*/", ""))
    print(string.gsub(content, "/%*.-%*/", ""))

    -- ? 进行匹配零或一次，可以匹配数字前带或不带 [+-]
    print(string.gsub("-123; +456; 7890;", "[+-]?%d+;", "number"))
end

print("------------------")
print("捕获：")
do
    pair = "name = jiang"
    key, value = string.match(pair, "(%a+)%s*=%s*(%a+)")
    print("捕获", key, value)

    pair = "name = jiang"
    key, value = string.match(pair, "%a+%s*=%s*%a+")
    print("常规", key, value)

    date = "Today is 12/04/1994"
    day, month, year = date:match("(%d+)/(%d+)/(%d+)")
    print(year, month, day)

    print("使用 %n :")
    s = [[then he said: "it's all right"]]
    -- 这里的匹配是 " ' 组合
    print(string.match(s, "[\"'].-[\"']"))
    -- 这里使用了 %1 ，表示和第一个捕获保持一致，例如此处为 " "
    -- 如果第一个匹配到的是 ' ，则为 ' '
    print(string.match(s, "([\"'])(.-)%1"))

    s = "Hello Lua!"
    -- %0 则表示每次匹配到的字符
    print(string.gsub(s, "%a", "%0-%0"))
    -- 此处 %1 和 %0 其实是一样的，因为只有一个匹配，没有什么区别
    print(string.gsub(s, "%a", "%1-%1"))
    -- 这里 %1 就是第一个捕获的内容， %2 就是第二个捕获的内容， %0 就是整个匹配内容
    print(string.gsub(s, "(.)(.)", "%2%1%0,"))
    print(string.gsub(s, "(.)(.)(.)", "%0 - %2"))
    -- %0 整个匹配内容，包括不在括号内的字符也囊括
    print(string.gsub(s, "(.).(.)", "%0,"))
end

print("------------------")
print("小例子：")
print("转 xml：")
do
    s = [[the \em{\bold{\quote{task}}} is to \em{change} that.]]
    print(s)
    -- 嵌套有问题
    print(string.gsub(s, "\\(%a+){(.-)}", "<%1>%2</%1>"))

    function toXML(s)
        -- %b{} 会进行 {} 成对
        s = string.gsub(s, "\\(%a+)(%b{})", function(tag, body)
            print(tag, body)
            body = string.sub(body, 2, -2)
            body = toXML(body)
            return string.format("<%s>%s</%s>", tag, body, tag)
        end)
        return s
    end
    print(toXML(s))
end

print("去空白：")
do
    function trim(s)
        return string.gsub(s, "^%s*(.+)%s*$", "%1")
    end
    print(trim("  jiang pengyong     "))
end

print("()获取位置：")
do
    print(string.match("hello jiang", "()ang()"))
    print(string.find("hello jiang", "ang"))
end

do
    function expandTabs(s, tab)
        tab = tab or 8
        local corr = 0
        return string.gsub(s, "()\t", function(p)
            local sp = tab - (p - 1 + corr) % tab
            corr = corr - 1 + sp
            return string.rep(" ", sp)
        end)
    end
    print("Hello\tjiang pengyong")
    print(expandTabs("Hello\tjiang pengyong"))
end